<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂùÇÂá∫Â∏Ç„Éû„ÉÉ„Éó„Éá„É¢ - Interactive Mapping Tool</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }
        
        #mapContainer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 4px solid rgba(255,255,255,0.3);
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .controlPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 320px;
            backdrop-filter: blur(10px);
        }
        
        .controlPanel h2 {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        
        .sectionBlock {
            margin-bottom: 18px;
            padding: 12px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
        }
        
        .sectionBlock h3 {
            font-size: 14px;
            color: #764ba2;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .actionBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            margin: 4px 2px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .actionBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
        }
        
        .actionBtn:active {
            transform: translateY(0);
        }
        
        .actionBtn.activeState {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .fileUploadLabel {
            display: inline-block;
            background: #4a5568;
            color: white;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 6px;
            transition: background 0.3s;
        }
        
        .fileUploadLabel:hover {
            background: #2d3748;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .tileUrlInput {
            width: 100%;
            padding: 8px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 12px;
            margin-top: 6px;
        }
        
        .tileUrlInput:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .infoDisplay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 18px;
            border-radius: 8px;
            z-index: 1000;
            font-size: 13px;
            color: #2d3748;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 400px;
        }
        
        .distanceMarker {
            background: #f093fb;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 11px;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="mapContainer"></div>
    
    <div class="controlPanel">
        <h2>üó∫Ô∏è ÂùÇÂá∫Â∏Ç„Éû„ÉÉ„Éó„ÉÑ„Éº„É´</h2>
        
        <div class="sectionBlock">
            <h3>üé® Base Layer Selector</h3>
            <button class="actionBtn" onclick="switchBasemap('osm')">OpenStreetMap</button>
            <button class="actionBtn" onclick="switchBasemap('satellite')">Satellite View</button>
            <button class="actionBtn" onclick="switchBasemap('terrain')">Terrain Map</button>
        </div>
        
        <div class="sectionBlock">
            <h3>üìè Distance Measurement</h3>
            <button class="actionBtn" id="measureToggle" onclick="toggleMeasurementMode()">Start Measuring</button>
            <button class="actionBtn" onclick="clearMeasurements()">Clear All</button>
        </div>
        
        <div class="sectionBlock">
            <h3>üìÅ Data Import</h3>
            <label class="fileUploadLabel">
                üìç Load GeoJSON
                <input type="file" accept=".geojson,.json" onchange="handleGeoJsonUpload(event)">
            </label>
            <label class="fileUploadLabel">
                üìä Load CSV
                <input type="file" accept=".csv" onchange="handleCsvUpload(event)">
            </label>
        </div>
        
        <div class="sectionBlock">
            <h3>üî≤ Vector Tiles (PBF)</h3>
            <input type="text" class="tileUrlInput" id="pbfUrlInput" 
                   placeholder="Enter MVT URL pattern: https://.../{z}/{x}/{y}.pbf">
            <button class="actionBtn" onclick="loadVectorTiles()" style="width: 100%; margin-top: 8px;">
                Load Vector Layer
            </button>
        </div>
    </div>
    
    <div class="infoDisplay" id="statusInfo">
        üìç ÂùÇÂá∫Â∏Ç, È¶ôÂ∑ùÁúå | Ready to explore
    </div>

    <script>
        // Initialize Sakaide City centered map
        const sakaideCityCoords = [34.3148, 133.8547];
        
        const mapInstance = L.map('mapContainer', {
            center: sakaideCityCoords,
            zoom: 13,
            zoomControl: true
        });
        
        // Base layer management system
        const basemapRegistry = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics',
                maxZoom: 18
            }),
            terrain: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: ¬© OpenStreetMap contributors, SRTM | Map style: ¬© OpenTopoMap',
                maxZoom: 17
            })
        };
        
        let activeBasemap = 'osm';
        basemapRegistry.osm.addTo(mapInstance);
        
        function switchBasemap(layerKey) {
            if (basemapRegistry[activeBasemap]) {
                mapInstance.removeLayer(basemapRegistry[activeBasemap]);
            }
            if (basemapRegistry[layerKey]) {
                basemapRegistry[layerKey].addTo(mapInstance);
                activeBasemap = layerKey;
                updateStatus(`Base layer switched to: ${layerKey.toUpperCase()}`);
            }
        }
        
        // Distance measurement system
        let measurementActive = false;
        let measurementPoints = [];
        let measurementMarkers = [];
        let measurementLines = [];
        
        function toggleMeasurementMode() {
            measurementActive = !measurementActive;
            const btn = document.getElementById('measureToggle');
            
            if (measurementActive) {
                btn.classList.add('activeState');
                btn.textContent = 'Measuring... (Click map)';
                mapInstance.getContainer().style.cursor = 'crosshair';
                updateStatus('üìè Click on map to measure distances');
            } else {
                btn.classList.remove('activeState');
                btn.textContent = 'Start Measuring';
                mapInstance.getContainer().style.cursor = '';
                updateStatus('Measurement mode disabled');
            }
        }
        
        mapInstance.on('click', function(evt) {
            if (!measurementActive) return;
            
            const clickedLatLng = evt.latlng;
            measurementPoints.push(clickedLatLng);
            
            // Add marker at clicked point
            const pointMarker = L.circleMarker(clickedLatLng, {
                radius: 6,
                fillColor: '#f093fb',
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(mapInstance);
            measurementMarkers.push(pointMarker);
            
            // Calculate distance if we have at least 2 points
            if (measurementPoints.length >= 2) {
                const prevPoint = measurementPoints[measurementPoints.length - 2];
                const currPoint = measurementPoints[measurementPoints.length - 1];
                
                // Use turf.js for accurate distance calculation
                const point1 = turf.point([prevPoint.lng, prevPoint.lat]);
                const point2 = turf.point([currPoint.lng, currPoint.lat]);
                const distanceKm = turf.distance(point1, point2, {units: 'kilometers'});
                const distanceM = distanceKm * 1000;
                
                // Draw line between points
                const segmentLine = L.polyline([prevPoint, currPoint], {
                    color: '#667eea',
                    weight: 3,
                    opacity: 0.8
                }).addTo(mapInstance);
                measurementLines.push(segmentLine);
                
                // Add distance label
                const midLat = (prevPoint.lat + currPoint.lat) / 2;
                const midLng = (prevPoint.lng + currPoint.lng) / 2;
                
                const distanceLabel = L.marker([midLat, midLng], {
                    icon: L.divIcon({
                        className: 'distanceMarker',
                        html: distanceM < 1000 ? 
                              `${distanceM.toFixed(1)}m` : 
                              `${distanceKm.toFixed(2)}km`
                    })
                }).addTo(mapInstance);
                measurementMarkers.push(distanceLabel);
                
                updateStatus(`Segment: ${distanceM < 1000 ? distanceM.toFixed(1) + 'm' : distanceKm.toFixed(2) + 'km'} | Total points: ${measurementPoints.length}`);
            }
        });
        
        function clearMeasurements() {
            measurementPoints = [];
            measurementMarkers.forEach(m => mapInstance.removeLayer(m));
            measurementLines.forEach(l => mapInstance.removeLayer(l));
            measurementMarkers = [];
            measurementLines = [];
            updateStatus('All measurements cleared');
        }
        
        // GeoJSON file handler
        let loadedGeoJsonLayers = [];
        
        function handleGeoJsonUpload(evt) {
            const uploadedFile = evt.target.files[0];
            if (!uploadedFile) return;
            
            const fileReader = new FileReader();
            fileReader.onload = function(e) {
                try {
                    const geoData = JSON.parse(e.target.result);
                    
                    const geoJsonLayer = L.geoJSON(geoData, {
                        style: {
                            color: '#f5576c',
                            weight: 2,
                            opacity: 0.8,
                            fillOpacity: 0.4
                        },
                        pointToLayer: function(feature, latlng) {
                            return L.circleMarker(latlng, {
                                radius: 8,
                                fillColor: '#f5576c',
                                color: '#fff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.7
                            });
                        },
                        onEachFeature: function(feature, layer) {
                            if (feature.properties) {
                                const popupContent = Object.entries(feature.properties)
                                    .map(([k, v]) => `<b>${k}:</b> ${v}`)
                                    .join('<br>');
                                layer.bindPopup(popupContent);
                            }
                        }
                    }).addTo(mapInstance);
                    
                    loadedGeoJsonLayers.push(geoJsonLayer);
                    
                    // Fit bounds to loaded data
                    const bounds = geoJsonLayer.getBounds();
                    if (bounds.isValid()) {
                        mapInstance.fitBounds(bounds, {padding: [50, 50]});
                    }
                    
                    updateStatus(`‚úÖ GeoJSON loaded: ${uploadedFile.name}`);
                } catch (error) {
                    updateStatus(`‚ùå Error loading GeoJSON: ${error.message}`);
                }
            };
            fileReader.readAsText(uploadedFile);
            evt.target.value = ''; // Reset input
        }
        
        // CSV file handler with lat/lon detection
        let loadedCsvMarkers = [];
        
        function handleCsvUpload(evt) {
            const uploadedFile = evt.target.files[0];
            if (!uploadedFile) return;
            
            const fileReader = new FileReader();
            fileReader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    const rows = csvText.split('\n').filter(r => r.trim());
                    
                    if (rows.length < 2) {
                        updateStatus('‚ùå CSV file is empty or invalid');
                        return;
                    }
                    
                    const headers = rows[0].split(',').map(h => h.trim().toLowerCase());
                    
                    // Auto-detect coordinate columns
                    const latIdx = headers.findIndex(h => 
                        h.includes('lat') || h === 'y' || h.includes('latitude'));
                    const lngIdx = headers.findIndex(h => 
                        h.includes('lon') || h.includes('lng') || h === 'x' || h.includes('longitude'));
                    
                    if (latIdx === -1 || lngIdx === -1) {
                        updateStatus('‚ùå Could not find lat/lon columns in CSV');
                        return;
                    }
                    
                    let pointCount = 0;
                    
                    for (let i = 1; i < rows.length; i++) {
                        const cells = rows[i].split(',');
                        const latitude = parseFloat(cells[latIdx]);
                        const longitude = parseFloat(cells[lngIdx]);
                        
                        if (!isNaN(latitude) && !isNaN(longitude)) {
                            const markerPoint = L.marker([latitude, longitude], {
                                icon: L.divIcon({
                                    className: 'custom-csv-marker',
                                    html: '<div style="background: #764ba2; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">üìç</div>'
                                })
                            }).addTo(mapInstance);
                            
                            // Create popup with all data
                            const popupHtml = headers.map((h, idx) => 
                                `<b>${h}:</b> ${cells[idx] || 'N/A'}`
                            ).join('<br>');
                            markerPoint.bindPopup(popupHtml);
                            
                            loadedCsvMarkers.push(markerPoint);
                            pointCount++;
                        }
                    }
                    
                    updateStatus(`‚úÖ CSV loaded: ${pointCount} points from ${uploadedFile.name}`);
                } catch (error) {
                    updateStatus(`‚ùå Error loading CSV: ${error.message}`);
                }
            };
            fileReader.readAsText(uploadedFile);
            evt.target.value = ''; // Reset input
        }
        
        // Vector tile (PBF) loader
        let vectorTileLayer = null;
        
        function loadVectorTiles() {
            const urlPattern = document.getElementById('pbfUrlInput').value.trim();
            
            if (!urlPattern) {
                updateStatus('‚ùå Please enter a vector tile URL pattern');
                return;
            }
            
            // Remove existing vector layer if present
            if (vectorTileLayer) {
                mapInstance.removeLayer(vectorTileLayer);
            }
            
            try {
                vectorTileLayer = L.vectorGrid.protobuf(urlPattern, {
                    rendererFactory: L.canvas.tile,
                    vectorTileLayerStyles: {
                        // Default styling for all vector layers
                        'default': {
                            weight: 1,
                            color: '#f093fb',
                            opacity: 0.8,
                            fill: true,
                            fillColor: '#667eea',
                            fillOpacity: 0.3
                        }
                    },
                    interactive: true,
                    getFeatureId: function(f) {
                        return f.properties.id || f.properties.osm_id;
                    }
                }).addTo(mapInstance);
                
                vectorTileLayer.on('click', function(e) {
                    if (e.layer && e.layer.properties) {
                        const props = e.layer.properties;
                        const popupContent = Object.entries(props)
                            .slice(0, 10) // Limit to first 10 properties
                            .map(([k, v]) => `<b>${k}:</b> ${v}`)
                            .join('<br>');
                        
                        L.popup()
                            .setLatLng(e.latlng)
                            .setContent(popupContent)
                            .openOn(mapInstance);
                    }
                });
                
                updateStatus(`‚úÖ Vector tiles loaded from URL pattern`);
            } catch (error) {
                updateStatus(`‚ùå Error loading vector tiles: ${error.message}`);
            }
        }
        
        // Status message updater
        function updateStatus(message) {
            const statusElement = document.getElementById('statusInfo');
            statusElement.textContent = message;
            
            // Auto-fade back to default after 5 seconds
            setTimeout(() => {
                statusElement.textContent = 'üìç ÂùÇÂá∫Â∏Ç, È¶ôÂ∑ùÁúå | Ready to explore';
            }, 5000);
        }
        
        // Add a marker at Sakaide City center
        L.marker(sakaideCityCoords, {
            icon: L.divIcon({
                className: 'city-marker',
                html: '<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 8px 12px; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); border: 2px solid white;">üìç ÂùÇÂá∫Â∏Ç</div>'
            })
        }).addTo(mapInstance)
          .bindPopup('<h3 style="margin: 0 0 8px 0; color: #667eea;">ÂùÇÂá∫Â∏Ç</h3><p style="margin: 0;">È¶ôÂ∑ùÁúå„ÅÆÁæé„Åó„ÅÑÊ∏ØÁî∫<br>Sakaide City, Kagawa Prefecture</p>');
        
        console.log('üó∫Ô∏è Leaflet Map Demo initialized for ÂùÇÂá∫Â∏Ç');
        console.log('Features: Basemap switching, Distance measurement (turf.js), GeoJSON/CSV import, Vector tiles (PBF)');
    </script>
</body>
</html>
